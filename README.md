# Extending Service-Oriented Workflow Engines with Role-Based Access Control Models

This repository contains the research and implementation details of the thesis "Extending Service-Oriented Workflow Engines with Role-Based Access Control Models." The thesis explores integrating Role-Based Access Control (RBAC) models into service-oriented workflow engines to enhance security and manageability.

## Overview

This thesis aims to demonstrate how service-oriented workflow engines can be extended with RBAC models to provide a more secure and efficient way of managing access controls in business process management.

## Structure of the Repository

- `/Whiteboard`: The source code for the frontend RBAC Whiteboard
- `/backend`: Source code for the backend implementation, including the Flask server and mock printers
- `/concept`: The RBAC model architecture concept interpreted in Java language

## Getting Started

- Run `/Whiteboard/temp.html,` and draw the RBAC model as you want to
- Run `/Backend/app.py` for the backend service. Available endpoints see below, and this service is based on the Python Flask server
- *Optional: Run `/Backend/printers.py` to set up a mock local printers server for testing

### Prerequisites

#### Core Python Libraries:

- `Flask`: A lightweight WSGI web application framework.
- `urllib`: A module for opening and reading URLs.
- `xmltodict`: A Python module that makes working with XML feel like working with JSON.
- `requests`: A simple, yet elegant HTTP library.
- `BeautifulSoup`: A library for pulling data from HTML and XML files.
- `pandas`: An open-source data analysis and manipulation tool.
- `numpy`: A fundamental package for scientific computing with Python.
- `matplotlib`: A plotting library for the Python programming language and its numerical mathematics extension, NumPy.
- `scipy`: A Python-based open-source software ecosystem for mathematics, science, and engineering.

#### Additional Utilities: 

- `Flask-CORS`: A Flask extension for handling Cross-Origin Resource Sharing (CORS), making cross-origin AJAX possible.
- `threading`: A module for creating, starting, and controlling threads.


## URL endpoints in app.py

### GET Requests in the Service

Users can execute `app.py` to launch the Flask server the backend service provides. There are many HTML endpoints for retrieving different outcomes with GET requests, as introduced below:

#### 1. "/response/<string:op_name>"

This request will return the response sent by the Flask server. The parameter `op_name` here is the desired operation name, and "operation-op1" is used in the given example. The sample response message from the sample above is: 

> "Available Users: user-wikipedia, endpoint of the user: wikipedia.org/wiki. user-wikibooks, endpoint of the user: wikibooks.org/wiki. user-wiktionary, endpoint of the user: wiktionary.org/wiki. Fastest response is wikipedia.org/wiki from user-wiktionary".

According to the response, users can access various information, such as the available user endpoints and the endpoint with the fastest response. This response provides a succinct summary of the hierarchical model structure generated by the user on the RBAC whiteboard.

#### 2. "/access/<string:op_name>"

This request will retrieve all HTML elements from the attribute of the first available endpoint. The parameter "op_name" should correspond to the desired operation name. 

#### 3. "/fastest"

This request will return the attribute associated with the endpoint with the shortest response time and redirect the user to the page introduced by that attribute. When the endpoint is called, it is marked as "occupied," making it unavailable for subsequent calls for a brief time. The user will encounter the page element after the redirection to the page, and the endpoint will return to an unoccupied state, allowing subsequent user requests.

#### 4. "/fastest/html"

This request will also provide the attribute associated with the fastest response among endpoints, but the return value is the HTML elements instead. Users can fetch these elements as response messages with REST client services.

#### 5. "/epsilon"

This request will return the endpoint selected by the Epsilon-Greedy algorithm, and this approach will be introduced in detail later in this section. This request will also be applied for the validation of the project.

### POST Requests in the Service

#### 1. "/upload-xml"

This request allows users to upload XML data directly to the server without creating a model on the whiteboard system. When the XML data is successfully transmitted, the following messages will be printed out in the Flask server console:

1. **Process messages** -- Process messages like "Reading XML data..." and "XML Data received:" will be printed out.

2. **XML Content** -- The XML content submitted by the user will also be displayed, allowing the user to review the XML file and debug as needed. It's important to note that the XML file must follow the format specified earlier to be successfully processed by the backend service.

3. **Endpoints' Attributes and Their Response Time** -- Users can see all available unoccupied endpoints and their attribute and response time information. The backend service will select the fastest among them and label it the "fastest response." Users can access this endpoint with the fastest response using the appropriate GET method above.

4. **Response from the Service** -- Users would get the same message as the GET method for the above response message here.
